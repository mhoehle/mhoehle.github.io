<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Dynamic Programming for Super Six</title>
  <meta name="description" content="Abstract:">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="https://mhoehle.github.io/blog/2023/03/20/dynprog.html">
  <link rel="alternate" type="application/rss+xml" title="Theory meets practice..." href="https://mhoehle.github.io/blog/feed.xml">
</head>

<!-- https://docs.mathjax.org/en/v2.7-latest/start.html -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">Theory meets practice...</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/blog/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Dynamic Programming for Super Six</h1>
    <p class="post-meta"><time datetime="2023-03-20T00:00:00+01:00" itemprop="datePublished">Mar 20, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="abstract">Abstract:</h2>
<p>We use dynamic programming to find the optimal strategy for playing
Super Six when there are 2 players. To test the cross-language
capabilities of rmarkdown we solve the task by embedding our Python
implementation of the value iteration algorithm using the reticulate
R-package.</p>
<center>
<img
src="/blog/figure/source/2023-03-20-dynprog/optim_strategy-1.png" />
</center>
<p><br>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a>
This work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons
Attribution-ShareAlike 4.0 International License</a>. The <a
href="https://raw.githubusercontent.com/mhoehle/mhoehle.github.io/master/_source/blog2023-03-20-dynprog.Rmd">R-markdown
source code</a> of this blog is available under a <a
href="https://www.gnu.org/licenses/gpl-3.0.html">GNU General Public
License (GPL v3)</a> license from GitHub.</p>
<h2 id="introduction">Introduction</h2>
<p>The present post finds the optimal game strategy for playing the dice
game of Super Six with two players using dynamic programming to solve
the corresponding Markov Decision Process (MDP). We use the
<code>reticulate</code> R package to run our Python implementation of
value iteration within the rmarkdown document.</p>
<p>For more details about Super Six, see the previous Blog post <a
href="https://mhoehle.github.io/blog/2023/03/13/super6.html"><em>How to
Win a Game (or More) of Super Six</em></a> for a description of the
game. Appendix 1 of the post discussed optimal strategies. The present
post is a natural sucessor of this post, because it shows the details of
how to calculate an the optimal strategies for two player games by using
value iteration <span class="citation"
data-cites="russell_norvig2020">Sutton and Barto (2020)</span>. This IMO
provides a clearer way to get to the strategy than, e.g., <span
class="citation" data-cites="jehn2021">Jehn (2021)</span> or the C++
program by <a
href="https://github.com/mhoehle/mhoehle.github.io/blob/main/blog/figure/source/2023-03-13-super6/hultberg2.cpp">Nuno
Hulthberg</a>.</p>
<h2 id="notation">Notation</h2>
<p>In mathematical notation the current state <span
class="math inline">\(s\)</span> corresponds to the <span
class="math inline">\(i/j/k\)</span> situation, with <span
class="math inline">\(0\leq i\leq 5\)</span>, <span
class="math inline">\(j\geq 0\)</span> and <span
class="math inline">\(k\geq 0\)</span>.</p>
<p>In order to distinguish between the first turn of a player in a round
(where the dice has to be thrown) and the subsequent turns, where the
player can decide whether to throw the dice or stop, we add a fourth
component <span class="math inline">\(l\in \{0,1\}\)</span> to the
state, which is a binary indicator whether the move is a forced moved
(1) or not (0). The action space for a state <span
class="math inline">\(i/j/k/l\)</span> with <span
class="math inline">\(l=1\)</span> is <span
class="math inline">\(\mathcal{A}(s) = \{\texttt{throw}\}\)</span>,
whereas for <span class="math inline">\(l=0\)</span> it is <span
class="math inline">\(\mathcal{A}(s) =
\{\texttt{throw},\texttt{stop}\}\)</span>.</p>
<p>If <span class="math inline">\(j=0\)</span> while <span
class="math inline">\(k&gt;0\)</span> then Player 1 won. If <span
class="math inline">\(k=0\)</span> while <span
class="math inline">\(i&gt;0\)</span> then Player 2 won. In order to
handle this <em>episodic task</em> <span class="citation"
data-cites="sutton_burto2020">(Sutton and Barto 2020)</span> we
introduce an terminal state, which provides no additional future
reward.</p>
<h3 id="state-transition">State Transition</h3>
<p>The state transition probabilities of the Markov decision process are
given as follows. For each throw of the dice from an <span
class="math inline">\(i/j/k/l\)</span> state there are three cases to
consider when throwing the dice:</p>
<ol type="1">
<li>you roll a six (probability <span
class="math inline">\(\frac{1}{6}\)</span>) and move to the <span
class="math inline">\(i/(j-1)/k/0\)</span> state</li>
<li>(if <span class="math inline">\(0\leq i&lt; 5\)</span>) you hit a
free spot (probability <span
class="math inline">\(\frac{5-i}{6}\)</span>) and move to the <span
class="math inline">\((i+1)/j/k/0\)</span> state</li>
<li>(if <span class="math inline">\(0&lt;i\leq 5\)</span>) you hit an
already occupied spot (probability <span
class="math inline">\(\frac{i}{6}\)</span>) and it is your opponents
turn to play from an <span
class="math inline">\((i-1)/k/(j+1)/1\)</span> position</li>
</ol>
<p>If you decide to stop throwing (only possible if <span
class="math inline">\(l=0\)</span>) then it is the opponent’s turn to
play from an <span class="math inline">\(i/k/j/1\)</span> position.</p>
<p>As part of the calculations one needs to know what happens if Player
1 looses their turn (i.e. either by hitting an occupied spot or by
voluntarily deciding to stop) This depends on the strategy played by
Player 2. For simplicity we will assume that Player 2 plays the same
optimal strategy as Player 1. This also means that rewards in this
situation are just minus the rewards obtained from the corresponding
position.</p>
<h3 id="reward">Reward</h3>
<p>Eventually, the game will finish. Let <span
class="math inline">\(R(s,a,s&#39;)\)</span> be the reward function,
where action <span class="math inline">\(a\)</span> moves the decision
maker from state <span class="math inline">\(s\)</span> to <span
class="math inline">\(s&#39;\)</span>. In our problem, the reward will
only depend on <span class="math inline">\(s&#39;\)</span>. We have
<span class="math display">\[
R(s&#39;=(i,j,k,l)) = \left\{
\begin{array}{cl}
1 &amp; \text{if $j=0$ and $k&gt;0$} \\
-1 &amp; \text{if $k=0$ and $j&gt;0$} \\
0 &amp; \text{otherwise}
\end{array}
\right.
\]</span></p>
<p>Side note: Since linear transformations of the reward function leave
the optimal strategy unchanged <span class="citation"
data-cites="russell_norvig2020">(Sect. 17.1.3, Russell and Norvig
2020)</span>, it is equally possible to work with rewards <span
class="math inline">\(R^*(s&#39;=(i,j,k,l)) =
\frac{1}{2}R(s&#39;=(i,j,k,l)) + \frac{1}{2}\)</span>. This would imply
values 1 for winning and 0 for loosing and translates directly the
expected reward computations into computing expected probabilities for
winning, which is what <span class="citation" data-cites="jehn2021">Jehn
(2021)</span> computed.</p>
<h3 id="bellman-equations">Bellman equations</h3>
<p>The expected utility obtained from following stragy <span
class="math inline">\(\pi\)</span> is defined as <span
class="math display">\[
U^{\pi}(s) = E\left[ \sum_{t=0}^\infty R(S_t, \pi(S_t), S_{t+1})\right]
\]</span> The terminal state with future reward 0 ensures that <span
class="math inline">\(U^\pi(s)&lt;\infty\)</span>. No discounting of the
rewards is thus used in our approach. Our aim is now to find a strategy
<span class="math inline">\(\pi^*(s)\)</span>, which optimizes this
expected utility, i.e. <span class="math display">\[
\pi_s^* = \operatorname{argmax}_{\pi} U^{\pi}(s)
\]</span> For state <span class="math inline">\(s\)</span> we thus
choose the action that maximizes the reward for the next step plus the
expected utility of the subsequent states: <span class="math display">\[
\pi^*(s) = \operatorname{argmax}_{a\in \mathcal{A}(s)}
\sum_{s&#39;}P(s&#39;| s,a) \left[ R(s,a,s&#39;) +  \max_{a&#39;}
U(s&#39;) \right]
\]</span></p>
<p>This expressions for a state <span class="math inline">\(s\)</span>
is also called the <strong>Bellman equation</strong>:</p>
<p><span class="math display">\[\begin{align*}
U(s)
&amp;=\max_{a\in \mathcal{A}(s)} \sum_{s&#39;}P(s&#39;| s,a) \left[
R(s,a,s&#39;) + U(s&#39;)
\right]
\end{align*}\]</span></p>
<p>Hence, for a state <span class="math inline">\(i/j/k/0\)</span> the
action “continue” leads to to the following expansion of the sum term in
the above equation:</p>
<p><span class="math display">\[
\begin{align*}
&amp; \underbrace{\frac{1}{6} [R(i/j-1/k/0) +
U(i/j-1/k/0)]}_{\text{stick into hole}} \\
&amp;+ \underbrace{\frac{5-i}{6} [R(i+1/j-1/k/0)
+  U(i+1/j-1/k/0)]}_{\text{put stick into lid}}\\
&amp;- \underbrace{\frac{i}{6} [R(i-1/k/j+1/1)
+  U(i-1/k/j+1/1)]}_{\text{take stick from lid}}
\end{align*}
\]</span> and the action to stop has value <span
class="math inline">\(R(i-1/k/j+1/1) + U(i-1/k/j+1/1)\)</span>.</p>
<h2 id="value-iteration">Value Iteration</h2>
<p>We use <strong>value iteration</strong> <span class="citation"
data-cites="russell_norvig2020">(Sect. 17.2.1, Russell and Norvig
2020)</span>, <span class="citation" data-cites="sutton_burto2020">(Sect
4.4, Sutton and Barto 2020)</span> to solve the MDP. Let <span
class="math inline">\(U(s)\)</span> and <span
class="math inline">\(U&#39;\)</span> be collections, which contain the
value function for each <span class="math inline">\(s\)</span> in the
state space. We initialize <span
class="math inline">\(U(s)=U&#39;(s)=0\)</span> for all states and
proceed by the following algorithm:</p>
<hr />
<p><strong>Algorithm 1</strong>: Value iteration</p>
<hr />
<p><strong>repeat</strong></p>
<ol type="1">
<li><span class="math inline">\(U \gets U&#39;; \delta \gets
0\)</span></li>
<li><strong>For all</strong> states <span
class="math inline">\(s\)</span> <strong>do</strong>
<ol type="a">
<li><span class="math inline">\(U&#39;(s) \gets \max_{a\in
\mathcal{A}(s)} \sum_{s&#39;}P(s&#39;| s,a) \left[ R(s,a,s&#39;) +
U(s&#39;) \right]\)</span></li>
<li><strong>if</strong> <span class="math inline">\(|U(s&#39;)-U(s)|
&gt; \delta\)</span> <strong>then</strong> <span
class="math inline">\(\delta \gets |U(s&#39;)-U(s)|\)</span></li>
</ol></li>
</ol>
<p><strong>until</strong> <span class="math inline">\(\delta \leq
\epsilon\)</span>;</p>
<hr />
<p>
<p>The optimal action for state <span class="math inline">\(s\)</span>
is thus the action maximing the sum term in Step 2a, i.e. <span
class="math inline">\(\pi(s) = \operatorname{argmax}_{a\in
\mathcal{A}(s)} \sum_{s&#39;}P(s&#39;| s,a) \left[ R(s,a,s&#39;) +
\max_{a&#39;} U(s&#39;) \right]\)</span>. Either one computes this at
the end of the algorithm or one adds this book-keeping step as part of
step 2a in the value iteration algorithm. Technically, <span
class="math inline">\(\pi\approx \pi^*\)</span>, i.e. we only obtain an
estimate of the optimal strategy, because of the iterative nature of the
algorithm. However, one can show that with sufficient iterations we
converge towards <span class="math inline">\(\pi^*\)</span>.</p>
<h2 id="results">Results</h2>
<p>Applying the value iteration Python code for <span
class="math inline">\(n=7\)</span> (see code in the Appendix) gives the
optimal strategy. Furthermore, we also obtain the probabilities to win
from each state. We show the result for all states with at least 3
sticks in the lid. With less than 3 sticks the decision is always to
continue throwing.</p>
<p>In the output, the column <code>strategy</code> shows whether to
continue throwing the dice (<code>TRUE</code>) or not
(<code>FALSE</code>); the column <code>value</code> shows the expected
value <span class="math inline">\(U(s)\)</span> and <code>prob</code>
shows the expected probability to win the game given that the opponent
also follows the same optimal strategy. Note that for states with <span
class="math inline">\(l=1\)</span>, no choice is possible, i.e. one has
to continue no matter what. For these states the strategy column is
always <code>TRUE</code>.</p>
<pre><code>##    i j k l       value strategy      prob
## 1  5 1 1 1 -0.09741652     TRUE 0.4512917
## 2  5 1 1 0  0.09741652    FALSE 0.5487083
## 3  4 2 1 1 -0.36297663     TRUE 0.3185117
## 4  4 2 1 0 -0.31689982    FALSE 0.3415501
## 5  4 1 2 1  0.31689982     TRUE 0.6584499
## 6  4 1 2 0  0.36297663    FALSE 0.6814883
## 7  4 1 1 1  0.04845936     TRUE 0.5242297
## 8  4 1 1 0  0.04845936     TRUE 0.5242297
## 9  3 3 1 1 -0.52748432     TRUE 0.2362578
## 10 3 3 1 0 -0.52748432     TRUE 0.2362578
## 11 3 2 2 1  0.02465027     TRUE 0.5123251
## 12 3 2 2 0  0.02465027     TRUE 0.5123251
## 13 3 2 1 1 -0.27737920     TRUE 0.3613104
## 14 3 2 1 0 -0.27737920     TRUE 0.3613104
## 15 3 1 3 1  0.58093392     TRUE 0.7904670
## 16 3 1 3 0  0.58093392     TRUE 0.7904670
## 17 3 1 2 1  0.42731097     TRUE 0.7136555
## 18 3 1 2 0  0.42731097     TRUE 0.7136555
## 19 3 1 1 1  0.22509739     TRUE 0.6125487
## 20 3 1 1 0  0.22509739     TRUE 0.6125487</code></pre>
<p>One can, e.g., compare the results with the numbers in Fig. 4 of
<span class="citation" data-cites="jehn2021">Jehn (2021)</span>. The
optimal strategy for a two player game is thus to continue as long as
only three pits are filled. If four slots are filled, one would only
continue, if the situation is 4/1/1. If 5 pits are filled, one should
always stop (if possible). The figure below illustrates the strategy for
all <span class="math inline">\(l=0\)</span> states graphically: the
y-axis gives <span class="math inline">\(i\)</span>, whereas the label
of each box is <span class="math inline">\(j/k\)</span> followed by the
expected probability (with just 2 decimals) to win from this state:</p>
<p><img src="/blog/figure/source/2023-03-20-dynprog/optim_strategy-1.png" style="display: block; margin: auto;" /></p>
<h2 id="discussion">Discussion</h2>
<p>Dynamic programming is an important foundation for reinforcement
learning. We can use it to find optimal strategies in fully observable
stochastic environments. For environments with reasonable sized state
spaces and with a known stochastic model for the transitions between
states, dynamic programming is a direct method to get exact solutions.
No complex approximate solutions, as e.g. discussed in Part 2 of <span
class="citation" data-cites="sutton_burto2020">Sutton and Barto
(2020)</span>, are needed.</p>
<h2 id="appendix-python-code">Appendix: Python code</h2>
<p>The Python code for value iteration can be found as <a
href="/blog/figure/source/2023-03-20-dynprog/value_iteration.py"><code>value_iteration.py</code></a>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python implementation of value iteration to find the optimal strategy in Super Six  </span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Author: Michael Höhle</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Date:   2023-03-16</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Semi-manual translation of the R code in value_iteration.R to python with the </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># help of OpenAI&#39;s text-davinci-003 API playground feature https://platform.openai.com/playground/p/default-text-to-command?model=text-davinci-003.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_situations(n):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Returns all situations in a game with n sticks left</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of sticks left in the game</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">    list</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">        a list of with entries [i,j,k] </span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Number of sticks in the lid</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(n,<span class="dv">5</span>),<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of sticks of player 1</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Number of sticks of player 2</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> n <span class="op">-</span> i <span class="op">-</span> j</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Only add valid states</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i<span class="op">&gt;=</span><span class="dv">0</span>  <span class="kw">and</span> <span class="kw">not</span> (j<span class="op">&lt;=</span><span class="dv">0</span> <span class="kw">or</span> k<span class="op">&lt;=</span><span class="dv">0</span>)):</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Append the state as an array [i,j,k]</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                res.append([i,j,k])</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(res)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_states(n):</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;All states when there are n sticks in the game left</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">    We distinguish between states with a choice if to throw the dice and those without</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of sticks left in the game</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="co">    list</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="co">        a list of with entries [i,j,k] </span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span>   </span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    states <span class="op">=</span> []</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> make_situations(i)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Make list comprehension which adds a fourth component indicating if the move is forced (0=no, 1=yes)</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>            states.extend([x <span class="op">+</span> [j] <span class="cf">for</span> x <span class="kw">in</span> s])</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort the list</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    states.sort(reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(states)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> swap(state, forced_move <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a><span class="co">    Swap the number of sticks of player 1 and 2</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="co">    state : vector of length 4</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co">        The state of the game as a vector with 4 components</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="co">    forced_move : bool</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co">        If the move is forced (i.e. the player has to swap the sticks)</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a><span class="co">        The new state as a vector of length 4</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> [state[<span class="dv">0</span>], state[<span class="dv">2</span>], state[<span class="dv">1</span>], state[<span class="dv">3</span>]]</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (forced_move <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>        res[<span class="dv">3</span>] <span class="op">=</span> forced_move</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(res)</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_state(state, Delta, forced_move <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> [<span class="bu">sum</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">zip</span>(state, Delta)]</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (forced_move <span class="op">!=</span> <span class="va">None</span>):</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>        res[<span class="dv">3</span>] <span class="op">=</span> forced_move</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(res)</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> R(state):</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;The immediate reward function</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a><span class="co">    state : list</span></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a><span class="co">        The state of the game as a vector with 4 components</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a><span class="co">    double The reward R(state), i.e. 1 if player 1 wins, -1 if player 2 wins, 0 otherwise</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A terminal state (player 1 = 0)</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A terminal state (player 2 = 0)</span></span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state[<span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Other state (nothing)</span></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimal_strategy(n, debug<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;&quot;Find the optimal strategy for a game with n sticks left</span></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define local variables for the function</span></span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>    states <span class="op">=</span> make_states(n)</span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>    n_states <span class="op">=</span> <span class="bu">len</span>(states)</span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Storage of the value function</span></span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>    U_vec <span class="op">=</span> np.zeros(n_states)</span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>    U_vec_prime <span class="op">=</span> np.zeros(n_states)</span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Storage of the policy/strategy</span></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> np.full(n_states, np.nan)</span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Future reward function.</span></span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note terminating states (i=0 or j=0) have zero future reward.</span></span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The function uses a local variable states and the value function uvec. Might want to add this to the arguments</span></span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> U(state):</span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Terminal state (no future returns)</span></span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (state[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (state[<span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find index of the element matching in states vector</span></span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> states.index(state)</span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return value function of the state</span></span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U_vec[idx]</span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Loop controls</span></span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>    stop <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>    epsilon <span class="op">=</span> <span class="fl">1e-10</span></span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>    <span class="bu">iter</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Value iteration </span></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (stop <span class="op">==</span> <span class="va">False</span>):</span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a>        <span class="bu">iter</span> <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>        Delta <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Translate to integer configuration</span></span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> states[idx]</span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The 4 possible moves</span></span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Do vector addition of the variable state and [0, -1, 0, 0]</span></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>            state_six <span class="op">=</span> add_state(state,  [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], forced_move<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a>            state_free <span class="op">=</span> add_state(state, [<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], forced_move<span class="op">=</span><span class="va">False</span>)       </span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a>            state_occupied <span class="op">=</span> swap(add_state(state, [<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], forced_move<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a>            state_swap     <span class="op">=</span> swap(state, forced_move<span class="op">=</span><span class="va">True</span>)                 </span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Number of sticks in the lid</span></span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> state[<span class="dv">0</span>]</span>
<span id="cb2-164"><a href="#cb2-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-165"><a href="#cb2-165" aria-hidden="true" tabindex="-1"></a>            <span class="co">#Q(s, continue)</span></span>
<span id="cb2-166"><a href="#cb2-166" aria-hidden="true" tabindex="-1"></a>            qs_continue <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">6</span>  <span class="op">*</span> (R(state_six)  <span class="op">+</span>  U(state_six))) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb2-167"><a href="#cb2-167" aria-hidden="true" tabindex="-1"></a>                        ((<span class="dv">5</span><span class="op">-</span>i)<span class="op">/</span><span class="dv">6</span> <span class="op">*</span> (R(state_free) <span class="op">+</span>  U(state_free)) <span class="cf">if</span> i<span class="op">&lt;</span><span class="dv">5</span> <span class="cf">else</span> <span class="dv">0</span>) <span class="op">+</span> <span class="op">\</span></span>
<span id="cb2-168"><a href="#cb2-168" aria-hidden="true" tabindex="-1"></a>                        (i<span class="op">/</span><span class="dv">6</span>     <span class="op">*</span> (R(state_occupied) <span class="op">-</span> U(state_occupied)) <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb2-169"><a href="#cb2-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-170"><a href="#cb2-170" aria-hidden="true" tabindex="-1"></a>            <span class="co">#Q(s, stop)</span></span>
<span id="cb2-171"><a href="#cb2-171" aria-hidden="true" tabindex="-1"></a>            qs_stop <span class="op">=</span> <span class="op">-</span>(R(state_swap) <span class="op">+</span> U(state_swap))</span>
<span id="cb2-172"><a href="#cb2-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-173"><a href="#cb2-173" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Updated value &amp; strategy if there is a choice.</span></span>
<span id="cb2-174"><a href="#cb2-174" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (state[<span class="dv">3</span>]<span class="op">==</span><span class="dv">0</span>):</span>
<span id="cb2-175"><a href="#cb2-175" aria-hidden="true" tabindex="-1"></a>                U_vec_prime[idx] <span class="op">=</span> <span class="bu">max</span>(qs_continue, qs_stop)</span>
<span id="cb2-176"><a href="#cb2-176" aria-hidden="true" tabindex="-1"></a>                pi[idx] <span class="op">=</span> qs_continue <span class="op">&gt;</span> qs_stop</span>
<span id="cb2-177"><a href="#cb2-177" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co">#no choice</span></span>
<span id="cb2-178"><a href="#cb2-178" aria-hidden="true" tabindex="-1"></a>                U_vec_prime[idx] <span class="op">=</span> qs_continue</span>
<span id="cb2-179"><a href="#cb2-179" aria-hidden="true" tabindex="-1"></a>                pi[idx] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-180"><a href="#cb2-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-181"><a href="#cb2-181" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Discrepancy  </span></span>
<span id="cb2-182"><a href="#cb2-182" aria-hidden="true" tabindex="-1"></a>            Delta <span class="op">=</span> <span class="bu">max</span>(Delta, <span class="bu">abs</span>(U_vec[idx] <span class="op">-</span> U_vec_prime[idx]))</span>
<span id="cb2-183"><a href="#cb2-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-184"><a href="#cb2-184" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the value function by copying the new values</span></span>
<span id="cb2-185"><a href="#cb2-185" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Note: In NumPy, using &quot;=&quot; would only make a reference to the new vector</span></span>
<span id="cb2-186"><a href="#cb2-186" aria-hidden="true" tabindex="-1"></a>        <span class="co"># See https://www.geeksforgeeks.org/array-copying-in-python/</span></span>
<span id="cb2-187"><a href="#cb2-187" aria-hidden="true" tabindex="-1"></a>        U_vec <span class="op">=</span> U_vec_prime.copy()</span>
<span id="cb2-188"><a href="#cb2-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-189"><a href="#cb2-189" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Continue the value iteration?  </span></span>
<span id="cb2-190"><a href="#cb2-190" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (debug):</span>
<span id="cb2-191"><a href="#cb2-191" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;iter = &quot;</span>, <span class="bu">iter</span>, <span class="st">&quot;, Delta =&quot;</span>, Delta)  </span>
<span id="cb2-192"><a href="#cb2-192" aria-hidden="true" tabindex="-1"></a>        stop <span class="op">=</span> (Delta <span class="op">&lt;=</span> epsilon)</span>
<span id="cb2-193"><a href="#cb2-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-194"><a href="#cb2-194" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make a tibble containing the strategy  </span></span>
<span id="cb2-195"><a href="#cb2-195" aria-hidden="true" tabindex="-1"></a>    strategy <span class="op">=</span> pd.DataFrame({<span class="st">&#39;state&#39;</span>: states, <span class="st">&#39;value&#39;</span>: U_vec, <span class="st">&#39;strategy&#39;</span>: pi, <span class="st">&#39;prob&#39;</span>: <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>U_vec<span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span>})  </span>
<span id="cb2-196"><a href="#cb2-196" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split state column into 4 separate columns</span></span>
<span id="cb2-197"><a href="#cb2-197" aria-hidden="true" tabindex="-1"></a>    strategy[[<span class="st">&#39;i&#39;</span>,<span class="st">&#39;j&#39;</span>,<span class="st">&#39;k&#39;</span>,<span class="st">&#39;l&#39;</span>]] <span class="op">=</span> pd.DataFrame(strategy.state.tolist(), index<span class="op">=</span> strategy.index) </span>
<span id="cb2-198"><a href="#cb2-198" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Drop the state column</span></span>
<span id="cb2-199"><a href="#cb2-199" aria-hidden="true" tabindex="-1"></a>    strategy <span class="op">=</span> strategy.drop(columns<span class="op">=</span>[<span class="st">&#39;state&#39;</span>])</span>
<span id="cb2-200"><a href="#cb2-200" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert strategy to boolean</span></span>
<span id="cb2-201"><a href="#cb2-201" aria-hidden="true" tabindex="-1"></a>    strategy[<span class="st">&#39;strategy&#39;</span>] <span class="op">=</span> strategy[<span class="st">&#39;strategy&#39;</span>].astype(<span class="bu">bool</span>)</span>
<span id="cb2-202"><a href="#cb2-202" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Change the order such that the i,j,k,forced_move columns are shown first</span></span>
<span id="cb2-203"><a href="#cb2-203" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> strategy.columns.tolist()</span>
<span id="cb2-204"><a href="#cb2-204" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> cols[<span class="op">-</span><span class="dv">4</span>:] <span class="op">+</span> cols[:<span class="op">-</span><span class="dv">4</span>]</span>
<span id="cb2-205"><a href="#cb2-205" aria-hidden="true" tabindex="-1"></a>    strategy <span class="op">=</span> strategy[cols]</span>
<span id="cb2-206"><a href="#cb2-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-207"><a href="#cb2-207" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(strategy)</span>
<span id="cb2-208"><a href="#cb2-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-209"><a href="#cb2-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-210"><a href="#cb2-210" aria-hidden="true" tabindex="-1"></a><span class="co">#Test function</span></span>
<span id="cb2-211"><a href="#cb2-211" aria-hidden="true" tabindex="-1"></a><span class="co">#make_situations(6)</span></span>
<span id="cb2-212"><a href="#cb2-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-213"><a href="#cb2-213" aria-hidden="true" tabindex="-1"></a><span class="co"># Find optimal strategy for game with 6 sticks left</span></span>
<span id="cb2-214"><a href="#cb2-214" aria-hidden="true" tabindex="-1"></a>s_best <span class="op">=</span> optimal_strategy(<span class="dv">7</span>)</span>
<span id="cb2-215"><a href="#cb2-215" aria-hidden="true" tabindex="-1"></a><span class="co"># Print full strategy without row number, https://stackoverflow.com/questions/52396477/printing-a-pandas-dataframe-without-row-number-index</span></span>
<span id="cb2-216"><a href="#cb2-216" aria-hidden="true" tabindex="-1"></a><span class="co"># pd.set_option(&#39;display.max_rows&#39;, None)</span></span>
<span id="cb2-217"><a href="#cb2-217" aria-hidden="true" tabindex="-1"></a><span class="co"># print(s_best.to_string(index=False))</span></span></code></pre></div>
<h2 class="unnumbered" id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent"
role="list">
<div id="ref-jehn2021" class="csl-entry" role="listitem">
Jehn, Rüdiger. 2021. <span>“Optimum Strategies for the Game Super
Six.”</span> arXiv. <a
href="https://doi.org/10.48550/ARXIV.2109.10700">https://doi.org/10.48550/ARXIV.2109.10700</a>.
</div>
<div id="ref-russell_norvig2020" class="csl-entry" role="listitem">
Russell, S. J., and P. Norvig. 2020. <em>Artificial Intelligence: A
Modern Approach</em>. Pearson Series in Artificial Intelligence.
Pearson.
</div>
<div id="ref-sutton_burto2020" class="csl-entry" role="listitem">
Sutton, Richard S., and Andrew G. Barto. 2020. <em>Reinforcement
Learning - an Introduction</em>. 2nd ed. The MIT Press.
</div>
</div>

  </div>

</article>

	

<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     **/
    /**
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    **/
    var disqus_config = function () {
      this.page.url = "https://mhoehle.github.io/blog/2023/03/20/dynprog.html";
      this.page.identifier = "/2023/03/20/dynprog";
    };
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//hoehle.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Theory meets practice...</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Theory meets practice...</li>
          <li><a href="https://math-inf.uni-greifswald.de/en/michael-hoehle/">Michael Höhle</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/mhoehle"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">mhoehle</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/m_hoehle"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">m_hoehle</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A blog about statistics in theory and practice. Not always serious, not always flawless, but definitely a statistically flavoured bean.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
